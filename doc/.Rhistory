#train-test split
info <- read.csv(train_label_path)
if(!require("EBImage")){
install.packages("BiocManager")
BiocManager::install("EBImage")
}
if(!require("R.matlab")){
install.packages("R.matlab")
}
if(!require("readxl")){
install.packages("readxl")
}
if(!require("dplyr")){
install.packages("dplyr")
}
if(!require("readxl")){
install.packages("readxl")
}
if(!require("ggplot2")){
install.packages("ggplot2")
}
if(!require("caret")){
install.packages("caret")
}
if(!require("glmnet")){
install.packages("glmnet")
}
if(!require("WeightedROC")){
install.packages("WeightedROC")
}
if(!require("gbm")){
install.packages("gbm")
}
if(!require("xgboost")){
install.packages("xgboost")
}
if(!require("caret")){
install.packages("caret")
}
# Install Miniconda (https://docs.conda.io/en/latest/miniconda.html)
if(!require("keras")){
install.packages("keras")
}
if(!require("tensorflow")){
install.packages("tensorflow")
install_tensorflow()
}
use_condaenv("r-tensorflow")
library(keras)
library(tensorflow)
library(R.matlab)
library(readxl)
library(dplyr)
library(EBImage)
library(ggplot2)
library(caret)
library(glmnet)
library(WeightedROC)
library(gbm)
require(xgboost)
library(caret)
set.seed(2020)
# setwd("~/Project3-FacialEmotionRecognition/doc")
# here replace it with your own path or manually set it in RStudio to where this rmd file is located.
# use relative path for reproducibility
train_dir <- "../data/train_set/" # This will be modified for different data sets.
train_image_dir <- paste(train_dir, "images/", sep="")
train_pt_dir <- paste(train_dir,  "points/", sep="")
train_label_path <- paste(train_dir, "label.csv", sep="")
# run.cv <- TRUE # run cross-validation on the training set
# sample.reweight <- TRUE # run sample reweighting in model training
# K <- 5  # number of CV folds
# run.feature.train <- TRUE # process features for training set
# run.test <- TRUE # run evaluation on an independent test set
# run.feature.test <- TRUE # process features for test set
sample.reweight <- TRUE # run sample reweighting in model training
K <- 5  # number of CV folds
run.feature.train <- TRUE # process features for training set
run.feature.test <- TRUE # process features for test set
run.cv_gbm <- TRUE # run GBM cross-validation on the training set
run.test_gbm <- TRUE # run GBM evaluation on an independent test set
run.cv_xgboost <- TRUE # run DNN cross-validation on the training set
run.test_xgboost <- TRUE # run DNN evaluation on an independent test set
run.cv_dnn <- TRUE # run DNN cross-validation on the training set
run.test_dnn <- TRUE # run DNN evaluation on an independent test set
# GBM parameters
n.trees <- c(500, 100, 1500)
shrinkage <- c(0.01, 0.05, 0.1)
# XGBoost parameters
eta <- c(0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5)
colsample_bytree <- c(0.2, 0.5, 0.6, 0.7, 0.8, 0.9)
#train-test split
info <- read.csv(train_label_path)
n <- nrow(info)
n_train <- round(n*(4/5), 0)
train_idx <- sample(info$Index, n_train, replace = F)
test_idx <- setdiff(info$Index, train_idx)
n_files <- length(list.files(train_image_dir))
image_list <- list()
for(i in 1:100){
image_list[[i]] <- readImage(paste0(train_image_dir, sprintf("%04d", i), ".jpg"))
}
#function to read fiducial points
#input: index
#output: matrix of fiducial points corresponding to the index
readMat.matrix <- function(index){
return(round(readMat(paste0(train_pt_dir, sprintf("%04d", index), ".mat"))[[1]],0))
}
#load fiducial points
fiducial_pt_list <- lapply(1:n_files, readMat.matrix)
save(fiducial_pt_list, file="../output/fiducial_pt_list.RData")
length(fiducial_pt_list)
fiducial_pt_list[1]
foo <- fiducial_pt_list[1]
pairwise_dist <- function(vec){
### input: a vector(length n), output: a vector containing pairwise distances(length n(n-1)/2)
return(as.vector(dist(vec)))
}
as.vector(apply(foo, 2, pairwise_dist))
foo
apply(foo, 2, pairwise_dist)
dim(foo)
is.matrix(foo)
is.data.frame(foo)
foo <- fiducial_pt_list[[1]]
is.matrix(foo)
as.vector(apply(foo, 2, pairwise_dist))
dim(foo)
foo[1]
foo[[1]]
foo[1,]
pairwise_dist(c(foo[1,], foo[2,]))
apply(foo, 2, mean)
apply(foo, 2, pairwise_dist)
as.vector(apply(mat, 2, pairwise_dist))
as.vector(apply(foo, 2, pairwise_dist))
dim(apply(foo, 2, pairwise_dist))
